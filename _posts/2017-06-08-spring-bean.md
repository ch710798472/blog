---
layout: post
title: Spring Bean注入遇到new的对象，解决思路
category: java
modified: 2017-01-19
tags: [java]
comments: true
pinned: true
excerpt: "1.背景 2.原因分析 3.解决方案..."
---
### 1.背景
　　前几天在做某个项目的时候，遇到一个问题，容我缓缓道来。
   <br>因为项目比较急，一天讨论需求，一天开发测试发布，也是我经历的最紧急的开发节奏。俗话说的好，心急吃不了热豆腐。果然写完代码在测试的时候
   <br>发现一个致命的问题，某些对象为Null，经过debug发现，是这次的某些bean为null，但是为啥注入失败。
   <br>what the fuck?
   <br>经过尝试不管是@autowired还是@resource的注入方式都注入不进去，bean的声明也改了好多次反复检查，甚至有点怀疑是xml中的使用的是byName还是byType的问题。
　　
### 2.原因分析
   冷静下来分析代码，发现为Null的bean所在的二方包没有用到spring的bean管理对象，所有的对象都是new关键字new出来的，所以依赖注入的bean是注入不进去的。
   按照以往的经验，这个时候肯定是搞一个上下文的类，持有需要使用的bean的实例，然后传过来使用，但是开发时间只剩下两三个小时了，怎么办？
   <br>最小改动为原则，我并不想来一次大的改动，得不偿失，还要回归很对业务场景。
   <br>这个时候同时Y站了出来，说：哥来教你一个spring的奇淫巧技!
   <br>键盘 pa pa pa~
   <br>编译打包部署一气呵成，自测通过！
   <br>"what the fuck? 你做了什么？"

### 3.解决方案
　　技不如人，虚心请教。Y把这个奇淫巧技传授给我了，我瞬间觉得这种轻量级的取巧解决方案很是不错。虽然从代码的健壮性和可移植性来讲是不可取的，但是对于
   <br>当前的场景来说，是最有效的解决方案。
   解决方案如下：
   1. 先在二方包内新建一个类，取名xxxUtil or xxxBeanHolder之类的名字，把需要注入的bean的变量修饰成static，并且加上set方法(注意idea自动生成的
   <br>set方法是static的，我们需要去掉它)。
   2. 在系统应用中，配置好步骤1的bean，然后在把我们刚才新建的类也配置成bean，并且注入方式是你自己任选，一般byType比较靠谱，byName需要把步骤1中的变量名改成系统应用中的这个bean的名字。
   3. 这个时候在初始化的时候二方包中的类作为bean，它的static变量会被初始化，并且这个时候是在系统应用的spring里面get到这个bean注入进去。
   好了，到这儿就解决了，总之需要解决的问题是应用的bean如何传递给应用依赖的某二方包中用new关键字new出来的对象的使用。
   <br>ps：你知道为什么要用static吗？